#pragma config(Motor,  port3,           drive,         tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           arm,           tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           armPitch,      tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int positiveMovementSpeed = 127; // positive movement speed variables
int negativeMovementSpeed = -127; // negative movement speed variables

int liftSpeed = 87;// speed needed to make the motor lift the arm //
int neutralSpeed = 70;// speed needed to make the motor maintain the arm's position //
int lowerSpeed = 53;// speed needed to let gravity lower the arm at a reasonable rate //

bool speedChangeUp = false;
bool speedChangeDown = false;

int highLowSwitch = 1; // variable used to switch motor speed from fast to slow and vice versa

int joystickThreshold = 15; // variable that prevents accidental joystick bumps from moving the robot

task moveRobot() // Will move robot forward and backward with channel 3 movement
{
	while(true)// Program will constantly check for these events //
	{
		int driveVelocity = vexRT[Ch3]; // maps the drive motor direction and speed to channel 3
		int forwards = vexRT[Btn5U]; // maps varaible that moves robot forward to button 6U
		int backwards = vexRT[Btn5D]; //maps variable that moves robot backward to button 5U
		if (!(abs(driveVelocity) < joystickThreshold) && driveVelocity) /* to prevent accidental joystick bumps, when the joystick is moved enough, the motor starts */
		{
			 motor[drive] = driveVelocity; // sets 'drive' motor direction and speed as driveVelocity
			 wait1Msec(5000);
		}
		else
		{
			stopMotor(drive); // if channel 3 is not in use, stop motor 'drive'
		}
		if (forwards)// while button 5U is pressed the motor 'drive' goes at positiveMovementSpeed
		{
			motor[drive] = positiveMovementSpeed;
			wait1Msec(5000);
		}
		else// when Btn5U is released, the motor 'drive' will stop //
		{
			stopMotor(drive);
		}
		if (backwards)// while Btn5D is pressed the motor 'drive' goes at negativeMovementSpeed
		{
			motor[drive] = negativeMovementSpeed;
			wait1Msec(5000);
		}
		else// when Btn5D is released, the motor 'drive' will stop
		{
			stopMotor(drive);
		}
	}
}

task speedChange()
{
	while (true)
	{
		if (vexRT[Btn7D] && highLowSwitch == 1)
		{
			positiveMovementSpeed = 63;
			negativeMovementSpeed = -63;
			highLowSwitch *= -1;
			wait1Msec(1500);
		}
		if (vexRT[Btn7D] && highLowSwitch == -1)
		{
			positiveMovementSpeed = 127;
			negativeMovementSpeed = -127;
			highLowSwitch *= -1;
			wait1Msec(1500);
		}
	}
}

task armExtendRetract() // Moves arm forwards and backwards with channel 2 //
{
	while(true)// Program will constantly check for these events //
	{
		int armExtension = vexRT[Ch4]; // maps variable 'armExtension' to channel 4
		int extend = vexRT[Btn6U]; // maps variable 'extend' to Btn6U
		int retract = vexRT[Btn6D]; // maps variabe 'retract' to Btn6D

		if (!(abs(armExtension) < joystickThreshold))
		{
			motor[arm] = armExtension; // the direction and speed of motor 'arm' are determined
			wait1Msec(5000);
		}
		else
		{
			stopMotor(arm); // if the channel 2 joystick is not being used, stop the motor 'arm'
		}
		if (extend)// while Btn5D is pressed, set motor "arm" speed to 127 //
		{
			motor[arm] = positiveMovementSpeed;
			wait1Msec(5000);
		}
		else// once Btn5D is released, the motor will stop //
		{
			stopMotor(arm);
		}
		if (retract)// while Btn6D is pressed, set motor "arm" speed to -127 //
		{
			motor[arm] = negativeMovementSpeed;
			wait1Msec(5000);
		}
		else// once Btn6D is released, the motor will stop //
		{
			stopMotor(arm);
		}
	}
}

task armUpDown()
{
	while(true)
	{
		if (vexRT[Btn7U] && (speedChangeDown == false))
		{
			motor[armPitch] = liftSpeed;
			speedChangeUp = true;
			wait1Msec(500);
			motor[armPitch] = neutralSpeed;
			speedChangeUp = false;
		}
		if (vexRT[Btn7D] && (speedChangeUp == false))
		{
			motor[armPitch] = lowerSpeed;
			speedChangeDown = true;
			wait1Msec(500);
			motor[armPitch] = neutralSpeed;
			speedChangeDown = false;
		}
	}
}
task main()
{
	while(true)
	{
		startTask(moveRobot);// task which moves robot forwards and backwards
		startTask(armExtendRetract);// task which moves the arm forwards and backwards
		startTask(speedChange);// task which changes the speed of the motors
		startTask(armUpDown);
	}
}
