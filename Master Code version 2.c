#pragma config(Motor,  port2,           armTendon,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port4,           drive,         tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port6,           armPitch,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port7,           armPivot,      tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           reefClaws,     tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//////////////////////////////////////////////
//           {Cord to Port List}            //
//////////////////////////////////////////////
//[2]>     Tendon cord goes in port 2 .     //
//---|--------------------------------------//
// 3 |           Port 3 is empty.           //
//---|--------------------------------------//
//[4]>      Drive cord goes in port 4 .     //
//---|--------------------------------------//
// 5 |           Port 5 is empty.           //
//---|--------------------------------------//
//[6]>  Arm vertical motor goes to port 6.  //
//---|--------------------------------------//
//[7]> Arm horizontal motor goes to port 7. //
//---|--------------------------------------//
// 8 |           Port 8 is empty.           //
//---|--------------------------------------//
//[9]>      Claw cord goes in port 9 .      //
//////////////////////////////////////////////
//Aesthetic design courtesy of Grant Loving //
//////////////////////////////////////////////

//Controls//
//7U increases the speed of motor armPitch//
//7D decreases the speed of motor armPitch//
//7L stops motor armPitch//
//5U opens the claw//
//5D closes the claw//
//Channel 1 controls the speed of armPivot//
//Channel 3 drives the robot//
//Channel 2 controls the curve of the arm//

int stallSpeed = 0;
/*
integer variable "stallSpeed":
This variable is used to store and recall the desired speed of the arm's vertical movement
through use of the task "armUpDown". This task is designed so the speed is
incremented slowly, creating smoother movements, as opposed to abruptly starting and
stopping the motor.
*/

int tendonSpeed = 75;
/*
integer variable "tendonSpeed":
This variable is used to change the speed of the motor that pulls on and releases the
arm's "tendon".
*/

task driveRobot()// task to move the robot along current //
{
	while(true)
	{
		if((vexRT[Ch3] > 42) || (vexRT[Ch3] < -42))
		{
			motor[drive] = vexRT[Ch3];
		}
		else
		{
			motor[drive] = 0;
		}

		while(vexRT[Btn8L])
		{
			motor[drive] = -100;
		}
		while(vexRT[Btn8R])
		{
			motor[drive] = 100;
		}
	}
}

task armRotation()// task to control the horizontal rotation of the arm //
{
	if((vexRT[Ch1] > 42) || (vexRT[Ch1] < -42))
	{
		motor[armPivot] = vexRT[Ch1];
	}
	else
	{

		motor[armPivot] = 0;
	}
}

task tendonFlux()// task to control the extention and contraction of the arm //
{
	while(true)
	{
		if(vexRT[Btn7U])
		{
			motor[armTendon] = tendonSpeed;
		}
		else if(vexRT[Btn7D])
		{
			motor[armTendon] = -tendonSpeed;
		}
		else
		{
			motor[armTendon] = 0;
		}
	}
}

task clawControl()// task to control the claws //
{

	if(vexRT[Btn5D])
	{
		motor[reefClaws] = 127;
	}

	if(vexRT[Btn5U])
	{
		motor[reefClaws] = -127;
	}
}

void armSpeed()
{
	int speedChange = 80;


	if(vexRT[Ch2] < 0)
	{
		speedChange = -speedChange;
	}
	else
	{
		speedChange = abs(speedChange);
	}

	if(vexRT[Btn6U] && abs(vexRT[Ch2])> 0 && abs(vexRT[Ch2])<= 60)
	{
		stallSpeed = 0;
		motor[armPitch] = (stallSpeed + speedChange/4);
		//if(abs(stallSpeed) < 127)
		//{
			stallSpeed = (stallSpeed + speedChange/4);
			wait1Msec(250);
		//}
		/*else if(stallSpeed > 127)
		{
			stallSpeed = 126;
		}
		else
		{
			stallSpeed = -126;
		}
		*/
	}
	else if(vexRT[Btn6U] && abs(vexRT[Ch2])> 60)
	{
		stallSpeed = 0;
		motor[armPitch] = (stallSpeed + speedChange/3);
		//if(abs(stallSpeed) < 127)
		//{
			stallSpeed = (stallSpeed + speedChange/3);
			wait1Msec(250);
		/*}
		else if(stallSpeed > 127)
		{
			stallSpeed = 126;
		}
		else
		{
			stallSpeed = -126;
		}*/
	}
	else if(abs(vexRT[Ch2] )> 0 && abs(vexRT[Ch2] )<= 60)
	{
		stallSpeed = 0;
		motor[armPitch] = (stallSpeed + speedChange/2);
		//if(abs(stallSpeed) < 127)

	//	{
		stallSpeed = (stallSpeed + speedChange/2);
		wait1Msec(250);
		/*}
		else if(stallSpeed > 127)
		{
			stallSpeed = 126;
		}
		else
		{
			stallSpeed = -126;
		}*/
	}
	else if(abs(vexRT[Ch2])> 60)
	{
		stallSpeed = 0;
		motor[armPitch] = (stallSpeed + speedChange);
		//if(abs(stallSpeed)< 127)
		//{
			stallSpeed = (stallSpeed + speedChange);
			wait1Msec(250);
		/*
		}
		else if(stallSpeed > 127)
		{
			stallSpeed = 126;
		}
		else
		{
			stallSpeed = -126;
		}*/
	}
}
task armUpDown()// task to control the arm's vertical movement //
{
	while(true)
	{
		/*
		if(vexRT[Btn7U])
		{
		if(jointSpeed<=127)
		{
		jointSpeed += 1;
		motor[armPitch] = jointSpeed;
		wait1Msec(10);
		}
		else
		{
		jointSpeed = 127;
		motor[armPitch] = jointSpeed;
		}
		}
		if(vexRT[Btn7D])
		{
		if(jointSpeed>=-127)
		{
		jointSpeed -= 1;
		motor[armPitch] = jointSpeed;
		wait1Msec(10);
		}
		else
		{
		jointSpeed = -127;
		motor[armPitch] = jointSpeed;
		}
		}
		if(vexRT[Btn7L] && (jointSpeed > 7))
		{
		jointSpeed -= 7;
		motor[armPitch] = jointSpeed;
		}
		if(vexRT[Btn7L] && (jointSpeed < -7))
		{
		jointSpeed += 7;
		motor[armPitch] = jointSpeed;
		}
		if(vexRT[Btn7L] && (jointSpeed > -7) && (jointSpeed < 7))
		{
		jointSpeed = 0;
		motor[armPitch] = jointSpeed;
		}
		*/
		if(abs(vexRT[Ch2]) > 15)
		{
			armSpeed();
		}
		else
		{
			motor[armPitch] = stallSpeed;
		}
	}
}

task main()
{
	while(true)
	{
		startTask(armUpDown);
		startTask(clawControl);
		startTask(driveRobot);
		startTask(armRotation);
		startTask(tendonFlux);
	}
}
